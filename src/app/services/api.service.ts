//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from 'rxjs';
import {
  Injectable,
  Inject,
  Optional,
  InjectionToken as OpaqueToken,
} from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = 'https://wtpupgrade-api.azurewebsites.net';

@Injectable({
  providedIn: 'root',
})
export class NTVoyagerApiWtp {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = 'https://wtpupgrade-api.azurewebsites.net';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(
    body: RegisterUserCommand | undefined
  ): Observable<EntityCreateResponse> {
    let url_ = this.baseUrl + '/api/wtp/Auth/v2/Register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<EntityCreateResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<EntityCreateResponse>;
        })
      );
  }

  protected processRegister(
    response: HttpResponseBase
  ): Observable<EntityCreateResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EntityCreateResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EntityCreateResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  login(body: LoginDetailsCommand | undefined): Observable<LoginResponse> {
    let url_ = this.baseUrl + '/api/wtp/Auth/v2/Login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<LoginResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<LoginResponse>;
        })
      );
  }

  protected processLogin(
    response: HttpResponseBase
  ): Observable<LoginResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LoginResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LoginResponse>(null as any);
  }

  /**
   * @return Success
   */
  indexInstruments(): Observable<IndexInstrumentDTO[] | IndexInstrumentDTO> {
    let url_ = this.baseUrl + '/api/wtp/Index/v2/IndexInstruments';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIndexInstruments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIndexInstruments(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                IndexInstrumentDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              IndexInstrumentDTO[]
            >;
        })
      );
  }

  protected processIndexInstruments(
    response: HttpResponseBase
  ): Observable<IndexInstrumentDTO[] | IndexInstrumentDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(IndexInstrumentDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IndexInstrumentDTO[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePesks(
    body: IndexUpdatePesksCommand | undefined
  ): Observable<GenericResponse> {
    let url_ = this.baseUrl + '/api/wtp/Index/v2/UpdatePesks';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdatePesks(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdatePesks(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GenericResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GenericResponse>;
        })
      );
  }

  protected processUpdatePesks(
    response: HttpResponseBase
  ): Observable<GenericResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GenericResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GenericResponse>(null as any);
  }

  /**
   * @return Success
   */
  chartDataBasic(
    pesk: string,
    interval: string
  ): Observable<ChartDataPointDTO[] | ChartDataPointDTO> {
    let url_ =
      this.baseUrl + '/api/wtp/MarketData/v2/ChartDataIntrday/{pesk}/{interval}';
    if (pesk === undefined || pesk === null)
      throw new Error("The parameter 'pesk' must be defined.");
    url_ = url_.replace('{pesk}', encodeURIComponent('' + pesk));
    if (interval === undefined || interval === null)
      throw new Error("The parameter 'interval' must be defined.");
    url_ = url_.replace('{interval}', encodeURIComponent('' + interval));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };
    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChartDataBasic(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChartDataBasic(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ChartDataPointDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ChartDataPointDTO[]
            >;
        })
      );
  }

  protected processChartDataBasic(
    response: HttpResponseBase
  ): Observable<ChartDataPointDTO[] | ChartDataPointDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ChartDataPointDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ChartDataPointDTO[]>(null as any);
  }

  /**
   * @return Success
   */
  chartDataTechnical(
    pesk: string,
    fromDate: Date,
    toDate: Date
  ): Observable<ChartDataOhlcDto[] | ChartDataOhlcDto> {
    let url_ =
      this.baseUrl +
      '/api/wtp/MarketData/v2/ChartDataTechnical/{pesk}/{fromDate}/{toDate}';
    if (pesk === undefined || pesk === null)
      throw new Error("The parameter 'pesk' must be defined.");
    url_ = url_.replace('{pesk}', encodeURIComponent('' + pesk));
    if (fromDate === undefined || fromDate === null)
      throw new Error("The parameter 'fromDate' must be defined.");
    url_ = url_.replace(
      '{fromDate}',
      encodeURIComponent(fromDate ? '' + fromDate.toISOString() : 'null')
    );
    if (toDate === undefined || toDate === null)
      throw new Error("The parameter 'toDate' must be defined.");
    url_ = url_.replace(
      '{toDate}',
      encodeURIComponent(toDate ? '' + toDate.toISOString() : 'null')
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChartDataTechnical(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChartDataTechnical(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ChartDataOhlcDto[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ChartDataOhlcDto[]
            >;
        })
      );
  }

  protected processChartDataTechnical(
    response: HttpResponseBase
  ): Observable<ChartDataOhlcDto[] | ChartDataOhlcDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ChartDataOhlcDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ChartDataOhlcDto[]>(null as any);
  }

  /**
   * @return Success
   */
  search(
    searchString: string
  ): Observable<SearchInstrument[] | SearchInstrument> {
    let url_ = this.baseUrl + '/api/wtp/MarketData/v2/Search/{searchString}';
    if (searchString === undefined || searchString === null)
      throw new Error("The parameter 'searchString' must be defined.");
    url_ = url_.replace(
      '{searchString}',
      encodeURIComponent('' + searchString)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearch(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SearchInstrument[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SearchInstrument[]
            >;
        })
      );
  }

  protected processSearch(
    response: HttpResponseBase
  ): Observable<SearchInstrument[] | SearchInstrument> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SearchInstrument.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SearchInstrument[]>(null as any);
  }

  /**
   * @return Success
   */
  marketMovers(
    exchange: string,
    moverType: string,
    noOfRows: string,
  ): Observable<MarketMoverRow[] | MarketMoverRow> {
    let url_ =
      this.baseUrl +
      '/api/wtp/MarketData/v2/MarketMovers/{exchange}/{moverType}/{noOfRows}';
    if (exchange === undefined || exchange === null)
      throw new Error("The parameter 'exchange' must be defined.");
    url_ = url_.replace('{exchange}', encodeURIComponent('' + exchange));
    if (moverType === undefined || moverType === null)
      throw new Error("The parameter 'moverType' must be defined.");
    url_ = url_.replace('{moverType}', encodeURIComponent('' + moverType));
    url_ = url_.replace(/[?&]$/, '');
    if (noOfRows === undefined || noOfRows === null || noOfRows == '')
      noOfRows = '10';
    url_ = url_.replace('{noOfRows}', encodeURIComponent('' + noOfRows));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMarketMovers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMarketMovers(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MarketMoverRow[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              MarketMoverRow[]
            >;
        })
      );
  }

  protected processMarketMovers(
    response: HttpResponseBase
  ): Observable<MarketMoverRow[] | MarketMoverRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(MarketMoverRow.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<MarketMoverRow[]>(null as any);
  }

  /**
   * @return Success
   */
  newsHeadlines(exchange: string, noOfRows:string): Observable<NewsHeadline[] | NewsHeadline> {
    let url_ = this.baseUrl + '/api/wtp/MarketData/v2/NewsHeadlines/{exchange}/{noOfRows}';
    if (exchange === undefined || exchange === null)
      throw new Error("The parameter 'exchange' must be defined.");
    url_ = url_.replace('{exchange}', encodeURIComponent('' + exchange));
    url_ = url_.replace(/[?&]$/, '');
    if (noOfRows === undefined || noOfRows === null || noOfRows == '')
      noOfRows = '10';
    url_ = url_.replace('{noOfRows}', encodeURIComponent('' + noOfRows));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processNewsHeadlines(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processNewsHeadlines(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<NewsHeadline[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              NewsHeadline[]
            >;
        })
      );
  }

  protected processNewsHeadlines(
    response: HttpResponseBase
  ): Observable<NewsHeadline[] | NewsHeadline> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(NewsHeadline.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<NewsHeadline[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  orderSubmit(
    body: OrderCreateCommand | undefined
  ): Observable<EntityCreateResponse> {
    let url_ = this.baseUrl + '/api/wtp/OrderRouting/v2/OrderSubmit';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderSubmit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderSubmit(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<EntityCreateResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<EntityCreateResponse>;
        })
      );
  }

  protected processOrderSubmit(
    response: HttpResponseBase
  ): Observable<EntityCreateResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EntityCreateResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EntityCreateResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  orderCancel(
    body: OrderCancelCommand | undefined
  ): Observable<EntityCreateResponse> {
    let url_ = this.baseUrl + '/api/wtp/OrderRouting/v2/OrderCancel';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderCancel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderCancel(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<EntityCreateResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<EntityCreateResponse>;
        })
      );
  }

  protected processOrderCancel(
    response: HttpResponseBase
  ): Observable<EntityCreateResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EntityCreateResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EntityCreateResponse>(null as any);
  }

  /**
   * @return Success
   */
  tradableInstrumentsForPesk(
    pesk: string
  ): Observable<TradableInstrumentDTO[] | TradableInstrumentDTO> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/TradableInstrumentsForPesk/{pesk}';
    if (pesk === undefined || pesk === null)
      throw new Error("The parameter 'pesk' must be defined.");
    url_ = url_.replace('{pesk}', encodeURIComponent('' + pesk));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTradableInstrumentsForPesk(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTradableInstrumentsForPesk(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                TradableInstrumentDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              TradableInstrumentDTO[]
            >;
        })
      );
  }

  protected processTradableInstrumentsForPesk(
    response: HttpResponseBase
  ): Observable<TradableInstrumentDTO[] | TradableInstrumentDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(TradableInstrumentDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TradableInstrumentDTO[]>(null as any);
  }

  /**
   * @return Success
   */
  positions(accountId: string): Observable<PositionRow[] | PositionRow> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/Account/Positions/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPositions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPositions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PositionRow[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PositionRow[]
            >;
        })
      );
  }

  protected processPositions(
    response: HttpResponseBase
  ): Observable<PositionRow[] | PositionRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PositionRow.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PositionRow[]>(null as any);
  }

  /**
   * @param positionId (optional)
   * @return Success
   */
  positionDetail(
    positionId: string | undefined,
    tradeId: string
  ): Observable<PositionRow> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/Account/PositionDetail/{tradeId}?';
    if (tradeId === undefined || tradeId === null)
      throw new Error("The parameter 'tradeId' must be defined.");
    url_ = url_.replace('{tradeId}', encodeURIComponent('' + tradeId));
    if (positionId === null)
      throw new Error("The parameter 'positionId' cannot be null.");
    else if (positionId !== undefined)
      url_ += 'positionId=' + encodeURIComponent('' + positionId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPositionDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPositionDetail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PositionRow>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PositionRow>;
        })
      );
  }

  protected processPositionDetail(
    response: HttpResponseBase
  ): Observable<PositionRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PositionRow.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PositionRow>(null as any);
  }

  /**
   * @return Success
   */
  orders(accountId: string): Observable<OrderBookRow[] | OrderBookRow> {
    let url_ = this.baseUrl + '/api/wtp/Private/v2/Account/Orders/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderBookRow[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              OrderBookRow[]
            >;
        })
      );
  }

  protected processOrders(
    response: HttpResponseBase
  ): Observable<OrderBookRow[] | OrderBookRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(OrderBookRow.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<OrderBookRow[]>(null as any);
  }

  /**
   * @param orderId (optional)
   * @return Success
   */
  orderDetail(
    orderId: string | undefined,
    tradeId: string
  ): Observable<OrderBookRow> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/Account/OrderDetail/{tradeId}?';
    if (tradeId === undefined || tradeId === null)
      throw new Error("The parameter 'tradeId' must be defined.");
    url_ = url_.replace('{tradeId}', encodeURIComponent('' + tradeId));
    if (orderId === null)
      throw new Error("The parameter 'orderId' cannot be null.");
    else if (orderId !== undefined)
      url_ += 'orderId=' + encodeURIComponent('' + orderId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processOrderDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processOrderDetail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderBookRow>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<OrderBookRow>;
        })
      );
  }

  protected processOrderDetail(
    response: HttpResponseBase
  ): Observable<OrderBookRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrderBookRow.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<OrderBookRow>(null as any);
  }

  /**
   * @return Success
   */
  trades(accountId: string): Observable<TradesBookRow[] | TradesBookRow> {
    let url_ = this.baseUrl + '/api/wtp/Private/v2/Account/Trades/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTrades(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTrades(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TradesBookRow[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              TradesBookRow[]
            >;
        })
      );
  }

  protected processTrades(
    response: HttpResponseBase
  ): Observable<TradesBookRow[] | TradesBookRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(TradesBookRow.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TradesBookRow[]>(null as any);
  }

  /**
   * @return Success
   */
  tradeDetail(tradeId: string): Observable<TradesBookRow> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/Account/TradeDetail/{tradeId}';
    if (tradeId === undefined || tradeId === null)
      throw new Error("The parameter 'tradeId' must be defined.");
    url_ = url_.replace('{tradeId}', encodeURIComponent('' + tradeId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTradeDetail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTradeDetail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TradesBookRow>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TradesBookRow>;
        })
      );
  }

  protected processTradeDetail(
    response: HttpResponseBase
  ): Observable<TradesBookRow> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TradesBookRow.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TradesBookRow>(null as any);
  }

  /**
   * @return Success
   */
  positionSummary(
    accountId: string
  ): Observable<PositionSummary[] | PositionSummary> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/Account/PositionSummary/{accountId}';
    if (accountId === undefined || accountId === null)
      throw new Error("The parameter 'accountId' must be defined.");
    url_ = url_.replace('{accountId}', encodeURIComponent('' + accountId));
    url_ = url_.replace(/[?&]$/, '');
    console.log(accountId)
    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPositionSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPositionSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                PositionSummary
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PositionSummary
            >;
        })
      );
  }

  protected processPositionSummary(
    response: HttpResponseBase
  ): Observable<PositionSummary[] | PositionSummary> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;
    
    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PositionSummary.fromJS(item));
          } else {
            result200 = resultData200;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<PositionSummary[]>(null as any);
  }

  /**
   * @return Success
   */
  details(fixSessionName: string): Observable<FixSessionDetailDTO> {
    let url_ =
      this.baseUrl + '/api/wtp/Private/v2/FixSessions/Details/{fixSessionName}';
    if (fixSessionName === undefined || fixSessionName === null)
      throw new Error("The parameter 'fixSessionName' must be defined.");
    url_ = url_.replace(
      '{fixSessionName}',
      encodeURIComponent('' + fixSessionName)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDetails(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<FixSessionDetailDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FixSessionDetailDTO>;
        })
      );
  }

  protected processDetails(
    response: HttpResponseBase
  ): Observable<FixSessionDetailDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = FixSessionDetailDTO.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FixSessionDetailDTO>(null as any);
  }

  /**
   * @return Success
   */
  instruments(fixSessionName: string): Observable<TradableInstrumentDTO> {
    let url_ =
      this.baseUrl +
      '/api/wtp/Private/v2/FixSessions/Instruments/{fixSessionName}';
    if (fixSessionName === undefined || fixSessionName === null)
      throw new Error("The parameter 'fixSessionName' must be defined.");
    url_ = url_.replace(
      '{fixSessionName}',
      encodeURIComponent('' + fixSessionName)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstruments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstruments(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<TradableInstrumentDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TradableInstrumentDTO>;
        })
      );
  }

  protected processInstruments(
    response: HttpResponseBase
  ): Observable<TradableInstrumentDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TradableInstrumentDTO.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TradableInstrumentDTO>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  calculateOrderCosts(
    body: OrderCostsCommand | undefined
  ): Observable<OrderCostsDTO> {
    let url_ = this.baseUrl + '/api/wtp/Private/v2/CalculateOrderCosts';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCalculateOrderCosts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCalculateOrderCosts(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OrderCostsDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<OrderCostsDTO>;
        })
      );
  }

  protected processCalculateOrderCosts(
    response: HttpResponseBase
  ): Observable<OrderCostsDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OrderCostsDTO.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<OrderCostsDTO>(null as any);
  }

  /**
   * @return Success
   */
  tradingAccounts(): Observable<TradingAccountDTO[] | TradingAccountDTO> {
    let url_ = this.baseUrl + '/api/wtp/User/v2/TradingAccounts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTradingAccounts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTradingAccounts(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                TradingAccountDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              TradingAccountDTO[]
            >;
        })
      );
  }

  protected processTradingAccounts(
    response: HttpResponseBase
  ): Observable<TradingAccountDTO[] | TradingAccountDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(TradingAccountDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<TradingAccountDTO[]>(null as any);
  }

  /**
   * @return Success
   */
  v2(): Observable<WatchlistDTO[] | WatchlistDTO> {
    let url_ = this.baseUrl + '/api/wtp/Watchlist/v2';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processV2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processV2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WatchlistDTO[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              WatchlistDTO[]
            >;
        })
      );
  }

  protected processV2(
    response: HttpResponseBase
  ): Observable<WatchlistDTO[] | WatchlistDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(WatchlistDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<WatchlistDTO[]>(null as any);
  }

  /**
   * @return Success
   */
  instrumentsAll(
    watchlistId: string
  ): Observable<WatchlistInstrumentDTO[] | WatchlistInstrumentDTO> {
    let url_ = this.baseUrl + '/api/wtp/Watchlist/v2/Instruments/{watchlistId}';
    if (watchlistId === undefined || watchlistId === null)
      throw new Error("The parameter 'watchlistId' must be defined.");
    url_ = url_.replace('{watchlistId}', encodeURIComponent('' + watchlistId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processInstrumentsAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processInstrumentsAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                WatchlistInstrumentDTO[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              WatchlistInstrumentDTO[]
            >;
        })
      );
  }

  protected processInstrumentsAll(
    response: HttpResponseBase
  ): Observable<WatchlistInstrumentDTO[] | WatchlistInstrumentDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(WatchlistInstrumentDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<WatchlistInstrumentDTO[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addNew(
    body: WatchlistCreateCommand | undefined
  ): Observable<GenericResponse> {
    let url_ = this.baseUrl + '/api/wtp/Watchlist/v2/AddNew';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddNew(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddNew(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GenericResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GenericResponse>;
        })
      );
  }

  protected processAddNew(
    response: HttpResponseBase
  ): Observable<GenericResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GenericResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GenericResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  rename(
    body: WatchlistRenameCommand | undefined
  ): Observable<GenericResponse> {
    let url_ = this.baseUrl + '/api/wtp/Watchlist/v2/Rename';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRename(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRename(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GenericResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GenericResponse>;
        })
      );
  }

  protected processRename(
    response: HttpResponseBase
  ): Observable<GenericResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GenericResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GenericResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatePesks2(
    body: WatchlistUpdatePesksCommand | undefined
  ): Observable<GenericResponse> {
    let url_ = this.baseUrl + '/api/wtp/Watchlist/v2/UpdatePesks';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdatePesks2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdatePesks2(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GenericResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GenericResponse>;
        })
      );
  }

  protected processUpdatePesks2(
    response: HttpResponseBase
  ): Observable<GenericResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GenericResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GenericResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  delete(
    body: WatchlistDeleteCommand | undefined
  ): Observable<GenericResponse> {
    let url_ = this.baseUrl + '/api/wtp/Watchlist/v2/delete';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GenericResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GenericResponse>;
        })
      );
  }

  protected processDelete(
    response: HttpResponseBase
  ): Observable<GenericResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GenericResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GenericResponse>(null as any);
  }
}

export class ChartDataOhlcDto implements IChartDataOhlcDto {
  date?: Date;
  openPrice?: number;
  highPrice?: number;
  lowPrice?: number;
  closePrice?: number;
  volume?: number;

  constructor(data?: IChartDataOhlcDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date']
        ? new Date(_data['date'].toString())
        : <any>undefined;
      this.openPrice = _data['openPrice'];
      this.highPrice = _data['highPrice'];
      this.lowPrice = _data['lowPrice'];
      this.closePrice = _data['closePrice'];
      this.volume = _data['volume'];
    }
  }

  static fromJS(data: any): ChartDataOhlcDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChartDataOhlcDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['openPrice'] = this.openPrice;
    data['highPrice'] = this.highPrice;
    data['lowPrice'] = this.lowPrice;
    data['closePrice'] = this.closePrice;
    data['volume'] = this.volume;
    return data;
  }
}

export interface IChartDataOhlcDto {
  date?: Date;
  openPrice?: number;
  highPrice?: number;
  lowPrice?: number;
  closePrice?: number;
  volume?: number;
}

export class ChartDataPointDTO implements IChartDataPointDTO {
  date?: Date;
  closePrice?: number;
  volume?: number;

  constructor(data?: IChartDataPointDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date']
        ? new Date(_data['date'].toString())
        : <any>undefined;
      this.closePrice = _data['closePrice'];
      this.volume = _data['volume'];
    }
  }

  static fromJS(data: any): ChartDataPointDTO {
    data = typeof data === 'object' ? data : {};
    let result = new ChartDataPointDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['closePrice'] = this.closePrice;
    data['volume'] = this.volume;
    return data;
  }
}

export interface IChartDataPointDTO {
  date?: Date;
  closePrice?: number;
  volume?: number;
}

export class CostRow implements ICostRow {
  amount?: number;
  description?: string | undefined;

  constructor(data?: ICostRow) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data['amount'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): CostRow {
    data = typeof data === 'object' ? data : {};
    let result = new CostRow();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['amount'] = this.amount;
    data['description'] = this.description;
    return data;
  }
}

export interface ICostRow {
  amount?: number;
  description?: string | undefined;
}

export class EntityCreateResponse implements IEntityCreateResponse {
  isSuccess?: boolean;
  message?: string | undefined;
  validationErrors?: string[] | undefined;
  newId?: string | undefined;

  constructor(data?: IEntityCreateResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.message = _data['message'];
      if (Array.isArray(_data['validationErrors'])) {
        this.validationErrors = [] as any;
        for (let item of _data['validationErrors'])
          this.validationErrors!.push(item);
      }
      this.newId = _data['newId'];
    }
  }

  static fromJS(data: any): EntityCreateResponse {
    data = typeof data === 'object' ? data : {};
    let result = new EntityCreateResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['message'] = this.message;
    if (Array.isArray(this.validationErrors)) {
      data['validationErrors'] = [];
      for (let item of this.validationErrors)
        data['validationErrors'].push(item);
    }
    data['newId'] = this.newId;
    return data;
  }
}

export interface IEntityCreateResponse {
  isSuccess?: boolean;
  message?: string | undefined;
  validationErrors?: string[] | undefined;
  newId?: string | undefined;
}

export class FixSessionDetailDTO implements IFixSessionDetailDTO {
  name?: string | undefined;
  active?: boolean;
  newOrderClassId?: string | undefined;
  editOrderClassId?: string | undefined;

  constructor(data?: IFixSessionDetailDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.active = _data['active'];
      this.newOrderClassId = _data['newOrderClassId'];
      this.editOrderClassId = _data['editOrderClassId'];
    }
  }

  static fromJS(data: any): FixSessionDetailDTO {
    data = typeof data === 'object' ? data : {};
    let result = new FixSessionDetailDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['active'] = this.active;
    data['newOrderClassId'] = this.newOrderClassId;
    data['editOrderClassId'] = this.editOrderClassId;
    return data;
  }
}

export interface IFixSessionDetailDTO {
  name?: string | undefined;
  active?: boolean;
  newOrderClassId?: string | undefined;
  editOrderClassId?: string | undefined;
}

export class GenericResponse implements IGenericResponse {
  isSuccess?: boolean;
  message?: string | undefined;
  validationErrors?: string[] | undefined;

  constructor(data?: IGenericResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.message = _data['message'];
      if (Array.isArray(_data['validationErrors'])) {
        this.validationErrors = [] as any;
        for (let item of _data['validationErrors'])
          this.validationErrors!.push(item);
      }
    }
  }

  static fromJS(data: any): GenericResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GenericResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['message'] = this.message;
    if (Array.isArray(this.validationErrors)) {
      data['validationErrors'] = [];
      for (let item of this.validationErrors)
        data['validationErrors'].push(item);
    }
    return data;
  }
}

export interface IGenericResponse {
  isSuccess?: boolean;
  message?: string | undefined;
  validationErrors?: string[] | undefined;
}

export class IndexInstrumentDTO implements IIndexInstrumentDTO {
  pesk?: string | undefined;
  index?: string | undefined;
  name?: string | undefined;
  value?: string | undefined;
  change?: string | undefined;
  changePercentage?: string | undefined;

  constructor(data?: IIndexInstrumentDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pesk = _data['pesk'];
      this.index = _data['index'];
      this.name = _data['name'];
      this.value = _data['value'];
      this.change = _data['change'];
      this.changePercentage = _data['changePercentage'];
    }
  }

  static fromJS(data: any): IndexInstrumentDTO {
    data = typeof data === 'object' ? data : {};
    let result = new IndexInstrumentDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pesk'] = this.pesk;
    data['index'] = this.index;
    data['name'] = this.name;
    data['value'] = this.value;
    data['change'] = this.change;
    data['changePercentage'] = this.changePercentage;
    return data;
  }
}

export interface IIndexInstrumentDTO {
  pesk?: string | undefined;
  index?: string | undefined;
  name?: string | undefined;
  value?: string | undefined;
  change?: string | undefined;
  changePercentage?: string | undefined;
}

export class IndexUpdatePesksCommand implements IIndexUpdatePesksCommand {
  pesks?: string[] | undefined;

  constructor(data?: IIndexUpdatePesksCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['pesks'])) {
        this.pesks = [] as any;
        for (let item of _data['pesks']) this.pesks!.push(item);
      }
    }
  }

  static fromJS(data: any): IndexUpdatePesksCommand {
    data = typeof data === 'object' ? data : {};
    let result = new IndexUpdatePesksCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.pesks)) {
      data['pesks'] = [];
      for (let item of this.pesks) data['pesks'].push(item);
    }
    return data;
  }
}

export interface IIndexUpdatePesksCommand {
  pesks?: string[] | undefined;
}

export class LoginDetailsCommand implements ILoginDetailsCommand {
  userName?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILoginDetailsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data['userName'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginDetailsCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginDetailsCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userName'] = this.userName;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginDetailsCommand {
  userName?: string | undefined;
  password?: string | undefined;
}

export class LoginResponse implements ILoginResponse {
  jwtToken?: string | undefined;
  isSuccess?: boolean;
  message?: string | undefined;
  userName?: string | undefined;
  displayName?: string | undefined;
  role?: string | undefined;
  email?: string | undefined;
  permissions?: { [key: string]: string } | undefined;

  constructor(data?: ILoginResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.jwtToken = _data['jwtToken'];
      this.isSuccess = _data['isSuccess'];
      this.message = _data['message'];
      this.userName = _data['userName'];
      this.displayName = _data['displayName'];
      this.role = _data['role'];
      this.email = _data['email'];
      if (_data['permissions']) {
        this.permissions = {} as any;
        for (let key in _data['permissions']) {
          if (_data['permissions'].hasOwnProperty(key))
            (<any>this.permissions)![key] = _data['permissions'][key];
        }
      }
    }
  }

  static fromJS(data: any): LoginResponse {
    data = typeof data === 'object' ? data : {};
    let result = new LoginResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['jwtToken'] = this.jwtToken;
    data['isSuccess'] = this.isSuccess;
    data['message'] = this.message;
    data['userName'] = this.userName;
    data['displayName'] = this.displayName;
    data['role'] = this.role;
    data['email'] = this.email;
    if (this.permissions) {
      data['permissions'] = {};
      for (let key in this.permissions) {
        if (this.permissions.hasOwnProperty(key))
          (<any>data['permissions'])[key] = (<any>this.permissions)[key];
      }
    }
    return data;
  }
}

export interface ILoginResponse {
  jwtToken?: string | undefined;
  isSuccess?: boolean;
  message?: string | undefined;
  userName?: string | undefined;
  displayName?: string | undefined;
  role?: string | undefined;
  email?: string | undefined;
  permissions?: { [key: string]: string } | undefined;
}

export class MarketMoverRow implements IMarketMoverRow {
  pesk?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  lastTrade?: number;
  change?: number;
  changePerc?: number;
  prevClose?: number;
  volume?: number;
  value?: number;
  noOfTrades?: number;

  constructor(data?: IMarketMoverRow) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pesk = _data['pesk'];
      this.symbol = _data['symbol'];
      this.name = _data['name'];
      this.lastTrade = _data['lastTrade'];
      this.change = _data['change'];
      this.changePerc = _data['changePerc'];
      this.prevClose = _data['prevClose'];
      this.volume = _data['volume'];
      this.value = _data['value'];
      this.noOfTrades = _data['noOfTrades'];
    }
  }

  static fromJS(data: any): MarketMoverRow {
    data = typeof data === 'object' ? data : {};
    let result = new MarketMoverRow();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pesk'] = this.pesk;
    data['symbol'] = this.symbol;
    data['name'] = this.name;
    data['lastTrade'] = this.lastTrade;
    data['change'] = this.change;
    data['changePerc'] = this.changePerc;
    data['prevClose'] = this.prevClose;
    data['volume'] = this.volume;
    data['value'] = this.value;
    data['noOfTrades'] = this.noOfTrades;
    return data;
  }
}

export interface IMarketMoverRow {
  pesk?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  lastTrade?: number;
  change?: number;
  changePerc?: number;
  prevClose?: number;
  volume?: number;
  value?: number;
  noOfTrades?: number;
}

export class NewsHeadline implements INewsHeadline {
  timeStamp?: Date;
  newsId?: string | undefined;
  headline?: string | undefined;
  symbols?: string[] | undefined;

  constructor(data?: INewsHeadline) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.timeStamp = _data['timeStamp']
        ? new Date(_data['timeStamp'].toString())
        : <any>undefined;
      this.newsId = _data['newsId'];
      this.headline = _data['headline'];
      if (Array.isArray(_data['symbols'])) {
        this.symbols = [] as any;
        for (let item of _data['symbols']) this.symbols!.push(item);
      }
    }
  }

  static fromJS(data: any): NewsHeadline {
    data = typeof data === 'object' ? data : {};
    let result = new NewsHeadline();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['timeStamp'] = this.timeStamp
      ? this.timeStamp.toISOString()
      : <any>undefined;
    data['newsId'] = this.newsId;
    data['headline'] = this.headline;
    if (Array.isArray(this.symbols)) {
      data['symbols'] = [];
      for (let item of this.symbols) data['symbols'].push(item);
    }
    return data;
  }
}

export interface INewsHeadline {
  timeStamp?: Date;
  newsId?: string | undefined;
  headline?: string | undefined;
  symbols?: string[] | undefined;
}

export class OrderBookRow implements IOrderBookRow {
  nutcrackerOrderId?: string | undefined;
  exchangeOrderId?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  tesk?: string | undefined;
  accountId?: string | undefined;
  accountNo?: string | undefined;
  side?: string | undefined;
  orderPrice?: number;
  orderQuantity?: number;
  tradedQuantity?: number;
  remainingQuantity?: number;
  vwap?: number;
  orderType?: string | undefined;
  timeInForce?: string | undefined;
  timeInForceDate?: Date | undefined;
  notes?: string | undefined;
  orderStatus?: string | undefined;
  traderId?: string | undefined;
  brokerId?: string | undefined;
  lastUpdateTime?: Date;
  lastUpdateId?: string | undefined;
  rejectedBy?: string | undefined;
  rejectReason?: string | undefined;

  constructor(data?: IOrderBookRow) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nutcrackerOrderId = _data['nutcrackerOrderId'];
      this.exchangeOrderId = _data['exchangeOrderId'];
      this.exchange = _data['exchange'];
      this.symbol = _data['symbol'];
      this.tesk = _data['tesk'];
      this.accountId = _data['accountId'];
      this.accountNo = _data['accountNo'];
      this.side = _data['side'];
      this.orderPrice = _data['orderPrice'];
      this.orderQuantity = _data['orderQuantity'];
      this.tradedQuantity = _data['tradedQuantity'];
      this.remainingQuantity = _data['remainingQuantity'];
      this.vwap = _data['vwap'];
      this.orderType = _data['orderType'];
      this.timeInForce = _data['timeInForce'];
      this.timeInForceDate = _data['timeInForceDate']
        ? new Date(_data['timeInForceDate'].toString())
        : <any>undefined;
      this.notes = _data['notes'];
      this.orderStatus = _data['orderStatus'];
      this.traderId = _data['traderId'];
      this.brokerId = _data['brokerId'];
      this.lastUpdateTime = _data['lastUpdateTime']
        ? new Date(_data['lastUpdateTime'].toString())
        : <any>undefined;
      this.lastUpdateId = _data['lastUpdateId'];
      this.rejectedBy = _data['rejectedBy'];
      this.rejectReason = _data['rejectReason'];
    }
  }

  static fromJS(data: any): OrderBookRow {
    data = typeof data === 'object' ? data : {};
    let result = new OrderBookRow();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nutcrackerOrderId'] = this.nutcrackerOrderId;
    data['exchangeOrderId'] = this.exchangeOrderId;
    data['exchange'] = this.exchange;
    data['symbol'] = this.symbol;
    data['tesk'] = this.tesk;
    data['accountId'] = this.accountId;
    data['accountNo'] = this.accountNo;
    data['side'] = this.side;
    data['orderPrice'] = this.orderPrice;
    data['orderQuantity'] = this.orderQuantity;
    data['tradedQuantity'] = this.tradedQuantity;
    data['remainingQuantity'] = this.remainingQuantity;
    data['vwap'] = this.vwap;
    data['orderType'] = this.orderType;
    data['timeInForce'] = this.timeInForce;
    data['timeInForceDate'] = this.timeInForceDate
      ? this.timeInForceDate.toISOString()
      : <any>undefined;
    data['notes'] = this.notes;
    data['orderStatus'] = this.orderStatus;
    data['traderId'] = this.traderId;
    data['brokerId'] = this.brokerId;
    data['lastUpdateTime'] = this.lastUpdateTime
      ? this.lastUpdateTime.toISOString()
      : <any>undefined;
    data['lastUpdateId'] = this.lastUpdateId;
    data['rejectedBy'] = this.rejectedBy;
    data['rejectReason'] = this.rejectReason;
    return data;
  }
}

export interface IOrderBookRow {
  nutcrackerOrderId?: string | undefined;
  exchangeOrderId?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  tesk?: string | undefined;
  accountId?: string | undefined;
  accountNo?: string | undefined;
  side?: string | undefined;
  orderPrice?: number;
  orderQuantity?: number;
  tradedQuantity?: number;
  remainingQuantity?: number;
  vwap?: number;
  orderType?: string | undefined;
  timeInForce?: string | undefined;
  timeInForceDate?: Date | undefined;
  notes?: string | undefined;
  orderStatus?: string | undefined;
  traderId?: string | undefined;
  brokerId?: string | undefined;
  lastUpdateTime?: Date;
  lastUpdateId?: string | undefined;
  rejectedBy?: string | undefined;
  rejectReason?: string | undefined;
}

export class OrderCancelCommand implements IOrderCancelCommand {
  nutcrackerOrderId?: string | undefined;
  instructionId?: string | undefined;

  constructor(data?: IOrderCancelCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.nutcrackerOrderId = _data['nutcrackerOrderId'];
      this.instructionId = _data['instructionId'];
    }
  }

  static fromJS(data: any): OrderCancelCommand {
    data = typeof data === 'object' ? data : {};
    let result = new OrderCancelCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['nutcrackerOrderId'] = this.nutcrackerOrderId;
    data['instructionId'] = this.instructionId;
    return data;
  }
}

export interface IOrderCancelCommand {
  nutcrackerOrderId?: string | undefined;
  instructionId?: string | undefined;
}

export class OrderCostsCommand implements IOrderCostsCommand {
  fixSession?: string | undefined;
  accountNo?: string | undefined;
  tesk?: string | undefined;
  currency?: string | undefined;
  price?: string | undefined;
  quantity?: string | undefined;
  side?: string | undefined;

  constructor(data?: IOrderCostsCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixSession = _data['fixSession'];
      this.accountNo = _data['accountNo'];
      this.tesk = _data['tesk'];
      this.currency = _data['currency'];
      this.price = _data['price'];
      this.quantity = _data['quantity'];
      this.side = _data['side'];
    }
  }

  static fromJS(data: any): OrderCostsCommand {
    data = typeof data === 'object' ? data : {};
    let result = new OrderCostsCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fixSession'] = this.fixSession;
    data['accountNo'] = this.accountNo;
    data['tesk'] = this.tesk;
    data['currency'] = this.currency;
    data['price'] = this.price;
    data['quantity'] = this.quantity;
    data['side'] = this.side;
    return data;
  }
}

export interface IOrderCostsCommand {
  fixSession?: string | undefined;
  accountNo?: string | undefined;
  tesk?: string | undefined;
  currency?: string | undefined;
  price?: string | undefined;
  quantity?: string | undefined;
  side?: string | undefined;
}

export class OrderCostsDTO implements IOrderCostsDTO {
  fixSession?: string | undefined;
  accountNo?: string | undefined;
  currency?: string | undefined;
  tesk?: string | undefined;
  totalFees?: number;
  cashAvailable?: number;
  initialMargin?: number;
  nominal?: number;
  feeDetails?: CostRow[] | undefined;
  userState?: string | undefined;
  cashRemaining?: number;

  constructor(data?: IOrderCostsDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixSession = _data['fixSession'];
      this.accountNo = _data['accountNo'];
      this.currency = _data['currency'];
      this.tesk = _data['tesk'];
      this.totalFees = _data['totalFees'];
      this.cashAvailable = _data['cashAvailable'];
      this.initialMargin = _data['initialMargin'];
      this.nominal = _data['nominal'];
      if (Array.isArray(_data['feeDetails'])) {
        this.feeDetails = [] as any;
        for (let item of _data['feeDetails'])
          this.feeDetails!.push(CostRow.fromJS(item));
      }
      this.userState = _data['userState'];
      this.cashRemaining = _data['cashRemaining'];
    }
  }

  static fromJS(data: any): OrderCostsDTO {
    data = typeof data === 'object' ? data : {};
    let result = new OrderCostsDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fixSession'] = this.fixSession;
    data['accountNo'] = this.accountNo;
    data['currency'] = this.currency;
    data['tesk'] = this.tesk;
    data['totalFees'] = this.totalFees;
    data['cashAvailable'] = this.cashAvailable;
    data['initialMargin'] = this.initialMargin;
    data['nominal'] = this.nominal;
    if (Array.isArray(this.feeDetails)) {
      data['feeDetails'] = [];
      for (let item of this.feeDetails) data['feeDetails'].push(item.toJSON());
    }
    data['userState'] = this.userState;
    data['cashRemaining'] = this.cashRemaining;
    return data;
  }
}

export interface IOrderCostsDTO {
  fixSession?: string | undefined;
  accountNo?: string | undefined;
  currency?: string | undefined;
  tesk?: string | undefined;
  totalFees?: number;
  cashAvailable?: number;
  initialMargin?: number;
  nominal?: number;
  feeDetails?: CostRow[] | undefined;
  userState?: string | undefined;
  cashRemaining?: number;
}

export class OrderCreateCommand implements IOrderCreateCommand {
  fixSession?: string | undefined;
  side?: string | undefined;
  exchange?: string | undefined;
  pesk?: string | undefined;
  symbol?: string | undefined;
  price?: number;
  quantity?: number;
  accountNo?: string | undefined;
  orderType?: string | undefined;
  timeInForce?: string | undefined;
  expiry?: string | undefined;
  notes?: string | undefined;
  additionalFields?: string[] | undefined;

  constructor(data?: IOrderCreateCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixSession = _data['fixSession'];
      this.side = _data['side'];
      this.exchange = _data['exchange'];
      this.pesk = _data['pesk'];
      this.symbol = _data['symbol'];
      this.price = _data['price'];
      this.quantity = _data['quantity'];
      this.accountNo = _data['accountNo'];
      this.orderType = _data['orderType'];
      this.timeInForce = _data['timeInForce'];
      this.expiry = _data['expiry'];
      this.notes = _data['notes'];
      if (Array.isArray(_data['additionalFields'])) {
        this.additionalFields = [] as any;
        for (let item of _data['additionalFields'])
          this.additionalFields!.push(item);
      }
    }
  }

  static fromJS(data: any): OrderCreateCommand {
    data = typeof data === 'object' ? data : {};
    let result = new OrderCreateCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fixSession'] = this.fixSession;
    data['side'] = this.side;
    data['exchange'] = this.exchange;
    data['pesk'] = this.pesk;
    data['symbol'] = this.symbol;
    data['price'] = this.price;
    data['quantity'] = this.quantity;
    data['accountNo'] = this.accountNo;
    data['orderType'] = this.orderType;
    data['timeInForce'] = this.timeInForce;
    data['expiry'] = this.expiry;
    data['notes'] = this.notes;
    if (Array.isArray(this.additionalFields)) {
      data['additionalFields'] = [];
      for (let item of this.additionalFields)
        data['additionalFields'].push(item);
    }
    return data;
  }
}

export interface IOrderCreateCommand {
  fixSession?: string | undefined;
  side?: string | undefined;
  exchange?: string | undefined;
  pesk?: string | undefined;
  symbol?: string | undefined;
  price?: number;
  quantity?: number;
  accountNo?: string | undefined;
  orderType?: string | undefined;
  timeInForce?: string | undefined;
  expiry?: string | undefined;
  notes?: string | undefined;
  additionalFields?: string[] | undefined;
}

export class PositionRow implements IPositionRow {
  accountId?: string | undefined;
  accountNo?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  tesk?: string | undefined;
  positionDate?: Date | undefined;
  startPosition?: number | undefined;
  bought?: number | undefined;
  sold?: number | undefined;
  closePosition?: number | undefined;
  lastUpdated?: Date | undefined;
  totalCost?: number | undefined;
  rulingPrice?: number | undefined;
  exposure?: number | undefined;
  initialMargin?: number | undefined;
  variationMargin?: number | undefined;
  profitLoss?: number | undefined;
  yestClosePrice?: number | undefined;

  constructor(data?: IPositionRow) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accountId = _data['accountId'];
      this.accountNo = _data['accountNo'];
      this.exchange = _data['exchange'];
      this.symbol = _data['symbol'];
      this.tesk = _data['tesk'];
      this.positionDate = _data['positionDate']
        ? new Date(_data['positionDate'].toString())
        : <any>undefined;
      this.startPosition = _data['startPosition'];
      this.bought = _data['bought'];
      this.sold = _data['sold'];
      this.closePosition = _data['closePosition'];
      this.lastUpdated = _data['lastUpdated']
        ? new Date(_data['lastUpdated'].toString())
        : <any>undefined;
      this.totalCost = _data['totalCost'];
      this.rulingPrice = _data['rulingPrice'];
      this.exposure = _data['exposure'];
      this.initialMargin = _data['initialMargin'];
      this.variationMargin = _data['variationMargin'];
      this.profitLoss = _data['profitLoss'];
      this.yestClosePrice = _data['yestClosePrice'];
    }
  }

  static fromJS(data: any): PositionRow {
    data = typeof data === 'object' ? data : {};
    let result = new PositionRow();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accountId'] = this.accountId;
    data['accountNo'] = this.accountNo;
    data['exchange'] = this.exchange;
    data['symbol'] = this.symbol;
    data['tesk'] = this.tesk;
    data['positionDate'] = this.positionDate
      ? this.positionDate.toISOString()
      : <any>undefined;
    data['startPosition'] = this.startPosition;
    data['bought'] = this.bought;
    data['sold'] = this.sold;
    data['closePosition'] = this.closePosition;
    data['lastUpdated'] = this.lastUpdated
      ? this.lastUpdated.toISOString()
      : <any>undefined;
    data['totalCost'] = this.totalCost;
    data['rulingPrice'] = this.rulingPrice;
    data['exposure'] = this.exposure;
    data['initialMargin'] = this.initialMargin;
    data['variationMargin'] = this.variationMargin;
    data['profitLoss'] = this.profitLoss;
    data['yestClosePrice'] = this.yestClosePrice;
    return data;
  }
}

export interface IPositionRow {
  accountId?: string | undefined;
  accountNo?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  tesk?: string | undefined;
  positionDate?: Date | undefined;
  startPosition?: number | undefined;
  bought?: number | undefined;
  sold?: number | undefined;
  closePosition?: number | undefined;
  lastUpdated?: Date | undefined;
  totalCost?: number | undefined;
  rulingPrice?: number | undefined;
  exposure?: number | undefined;
  initialMargin?: number | undefined;
  variationMargin?: number | undefined;
  profitLoss?: number | undefined;
  yestClosePrice?: number | undefined;
}

export class PositionSummary implements IPositionSummary {
  longExposure?: number;
  shortExposure?: number;
  portfolioValue?: number;
  availableCash?: number;
  readonly gearing?: number;

  constructor(data?: IPositionSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.longExposure = _data['longExposure'];
      this.shortExposure = _data['shortExposure'];
      this.portfolioValue = _data['portfolioValue'];
      this.availableCash = _data['availableCash'];
      (<any>this).gearing = _data['gearing'];
    }
  }

  static fromJS(data: any): PositionSummary {
    data = typeof data === 'object' ? data : {};
    let result = new PositionSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['longExposure'] = this.longExposure;
    data['shortExposure'] = this.shortExposure;
    data['portfolioValue'] = this.portfolioValue;
    data['availableCash'] = this.availableCash;
    data['gearing'] = this.gearing;
    return data;
  }
}

export interface IPositionSummary {
  longExposure?: number;
  shortExposure?: number;
  portfolioValue?: number;
  availableCash?: number;
  gearing?: number;
}

export class RegisterUserCommand implements IRegisterUserCommand {
  forWhichApplication?: string | undefined;
  fromWhichDevice?: string | undefined;
  title?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  note?: string | undefined;

  constructor(data?: IRegisterUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.forWhichApplication = _data['forWhichApplication'];
      this.fromWhichDevice = _data['fromWhichDevice'];
      this.title = _data['title'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.email = _data['email'];
      this.phone = _data['phone'];
      this.password = _data['password'];
      this.note = _data['note'];
    }
  }

  static fromJS(data: any): RegisterUserCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterUserCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['forWhichApplication'] = this.forWhichApplication;
    data['fromWhichDevice'] = this.fromWhichDevice;
    data['title'] = this.title;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['email'] = this.email;
    data['phone'] = this.phone;
    data['password'] = this.password;
    data['note'] = this.note;
    return data;
  }
}

export interface IRegisterUserCommand {
  forWhichApplication?: string | undefined;
  fromWhichDevice?: string | undefined;
  title?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  note?: string | undefined;
}

export class SearchInstrument implements ISearchInstrument {
  pesk?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  instrumentType?: string | undefined;
  sector?: string | undefined;
  index?: string | undefined;

  constructor(data?: ISearchInstrument) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pesk = _data['pesk'];
      this.exchange = _data['exchange'];
      this.symbol = _data['symbol'];
      this.name = _data['name'];
      this.instrumentType = _data['instrumentType'];
      this.sector = _data['sector'];
      this.index = _data['index'];
    }
  }

  static fromJS(data: any): SearchInstrument {
    data = typeof data === 'object' ? data : {};
    let result = new SearchInstrument();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pesk'] = this.pesk;
    data['exchange'] = this.exchange;
    data['symbol'] = this.symbol;
    data['name'] = this.name;
    data['instrumentType'] = this.instrumentType;
    data['sector'] = this.sector;
    data['index'] = this.index;
    return data;
  }
}

export interface ISearchInstrument {
  pesk?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  instrumentType?: string | undefined;
  sector?: string | undefined;
  index?: string | undefined;
}

export class TradableInstrumentDTO implements ITradableInstrumentDTO {
  tesk?: string | undefined;
  fixSession?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  pesk?: string | undefined;
  currency?: string | undefined;

  constructor(data?: ITradableInstrumentDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tesk = _data['tesk'];
      this.fixSession = _data['fixSession'];
      this.exchange = _data['exchange'];
      this.symbol = _data['symbol'];
      this.name = _data['name'];
      this.pesk = _data['pesk'];
      this.currency = _data['currency'];
    }
  }

  static fromJS(data: any): TradableInstrumentDTO {
    data = typeof data === 'object' ? data : {};
    let result = new TradableInstrumentDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tesk'] = this.tesk;
    data['fixSession'] = this.fixSession;
    data['exchange'] = this.exchange;
    data['symbol'] = this.symbol;
    data['name'] = this.name;
    data['pesk'] = this.pesk;
    data['currency'] = this.currency;
    return data;
  }
}

export interface ITradableInstrumentDTO {
  tesk?: string | undefined;
  fixSession?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  pesk?: string | undefined;
  currency?: string | undefined;
}

export class TradesBookRow implements ITradesBookRow {
  exchangeTradeID?: string | undefined;
  exchangeOrderId?: string | undefined;
  fixSessionID?: string | undefined;
  accountId?: string | undefined;
  accountNo?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  tesk?: string | undefined;
  side?: string | undefined;
  tradeQuantity?: number;
  tradePrice?: number;
  tradeDateTime?: Date;
  tradeType?: string | undefined;

  constructor(data?: ITradesBookRow) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.exchangeTradeID = _data['exchangeTradeID'];
      this.exchangeOrderId = _data['exchangeOrderId'];
      this.fixSessionID = _data['fixSessionID'];
      this.accountId = _data['accountId'];
      this.accountNo = _data['accountNo'];
      this.exchange = _data['exchange'];
      this.symbol = _data['symbol'];
      this.tesk = _data['tesk'];
      this.side = _data['side'];
      this.tradeQuantity = _data['tradeQuantity'];
      this.tradePrice = _data['tradePrice'];
      this.tradeDateTime = _data['tradeDateTime']
        ? new Date(_data['tradeDateTime'].toString())
        : <any>undefined;
      this.tradeType = _data['tradeType'];
    }
  }

  static fromJS(data: any): TradesBookRow {
    data = typeof data === 'object' ? data : {};
    let result = new TradesBookRow();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['exchangeTradeID'] = this.exchangeTradeID;
    data['exchangeOrderId'] = this.exchangeOrderId;
    data['fixSessionID'] = this.fixSessionID;
    data['accountId'] = this.accountId;
    data['accountNo'] = this.accountNo;
    data['exchange'] = this.exchange;
    data['symbol'] = this.symbol;
    data['tesk'] = this.tesk;
    data['side'] = this.side;
    data['tradeQuantity'] = this.tradeQuantity;
    data['tradePrice'] = this.tradePrice;
    data['tradeDateTime'] = this.tradeDateTime
      ? this.tradeDateTime.toISOString()
      : <any>undefined;
    data['tradeType'] = this.tradeType;
    return data;
  }
}

export interface ITradesBookRow {
  exchangeTradeID?: string | undefined;
  exchangeOrderId?: string | undefined;
  fixSessionID?: string | undefined;
  accountId?: string | undefined;
  accountNo?: string | undefined;
  exchange?: string | undefined;
  symbol?: string | undefined;
  tesk?: string | undefined;
  side?: string | undefined;
  tradeQuantity?: number;
  tradePrice?: number;
  tradeDateTime?: Date;
  tradeType?: string | undefined;
}

export class TradingAccountDTO implements ITradingAccountDTO {
  fixSession?: string | undefined;
  accountNo?: string | undefined;
  name?: string | undefined;
  active?: boolean;
  freeInfo1?: string | undefined;
  freeInfo2?: string | undefined;
  freeInfo3?: string | undefined;
  freeInfo4?: string | undefined;
  freeInfo5?: string | undefined;

  constructor(data?: ITradingAccountDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixSession = _data['fixSession'];
      this.accountNo = _data['accountNo'];
      this.name = _data['name'];
      this.active = _data['active'];
      this.freeInfo1 = _data['freeInfo1'];
      this.freeInfo2 = _data['freeInfo2'];
      this.freeInfo3 = _data['freeInfo3'];
      this.freeInfo4 = _data['freeInfo4'];
      this.freeInfo5 = _data['freeInfo5'];
    }
  }

  static fromJS(data: any): TradingAccountDTO {
    data = typeof data === 'object' ? data : {};
    let result = new TradingAccountDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fixSession'] = this.fixSession;
    data['accountNo'] = this.accountNo;
    data['name'] = this.name;
    data['active'] = this.active;
    data['freeInfo1'] = this.freeInfo1;
    data['freeInfo2'] = this.freeInfo2;
    data['freeInfo3'] = this.freeInfo3;
    data['freeInfo4'] = this.freeInfo4;
    data['freeInfo5'] = this.freeInfo5;
    return data;
  }
}

export interface ITradingAccountDTO {
  fixSession?: string | undefined;
  accountNo?: string | undefined;
  name?: string | undefined;
  active?: boolean;
  freeInfo1?: string | undefined;
  freeInfo2?: string | undefined;
  freeInfo3?: string | undefined;
  freeInfo4?: string | undefined;
  freeInfo5?: string | undefined;
}

export class WatchlistCreateCommand implements IWatchlistCreateCommand {
  name?: string | undefined;
  pesks?: string[] | undefined;

  constructor(data?: IWatchlistCreateCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      if (Array.isArray(_data['pesks'])) {
        this.pesks = [] as any;
        for (let item of _data['pesks']) this.pesks!.push(item);
      }
    }
  }

  static fromJS(data: any): WatchlistCreateCommand {
    data = typeof data === 'object' ? data : {};
    let result = new WatchlistCreateCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    if (Array.isArray(this.pesks)) {
      data['pesks'] = [];
      for (let item of this.pesks) data['pesks'].push(item);
    }
    return data;
  }
}

export interface IWatchlistCreateCommand {
  name?: string | undefined;
  pesks?: string[] | undefined;
}

export class WatchlistDTO implements IWatchlistDTO {
  id?: string | undefined;
  name?: string | undefined;

  constructor(data?: IWatchlistDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): WatchlistDTO {
    data = typeof data === 'object' ? data : {};
    let result = new WatchlistDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IWatchlistDTO {
  id?: string | undefined;
  name?: string | undefined;
}

export class WatchlistDeleteCommand implements IWatchlistDeleteCommand {
  watchlistId?: string | undefined;

  constructor(data?: IWatchlistDeleteCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.watchlistId = _data['watchlistId'];
    }
  }

  static fromJS(data: any): WatchlistDeleteCommand {
    data = typeof data === 'object' ? data : {};
    let result = new WatchlistDeleteCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['watchlistId'] = this.watchlistId;
    return data;
  }
}

export interface IWatchlistDeleteCommand {
  watchlistId?: string | undefined;
}

export class WatchlistInstrumentDTO implements IWatchlistInstrumentDTO {
  pesk?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  instrumentType?: string | undefined;
  sector?: string | undefined;

  constructor(data?: IWatchlistInstrumentDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pesk = _data['pesk'];
      this.symbol = _data['symbol'];
      this.name = _data['name'];
      this.instrumentType = _data['instrumentType'];
      this.sector = _data['sector'];
    }
  }

  static fromJS(data: any): WatchlistInstrumentDTO {
    data = typeof data === 'object' ? data : {};
    let result = new WatchlistInstrumentDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pesk'] = this.pesk;
    data['symbol'] = this.symbol;
    data['name'] = this.name;
    data['instrumentType'] = this.instrumentType;
    data['sector'] = this.sector;
    return data;
  }
}

export interface IWatchlistInstrumentDTO {
  pesk?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  instrumentType?: string | undefined;
  sector?: string | undefined;
}

export class WatchlistRenameCommand implements IWatchlistRenameCommand {
  watchlistId?: string | undefined;
  newName?: string | undefined;

  constructor(data?: IWatchlistRenameCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.watchlistId = _data['watchlistId'];
      this.newName = _data['newName'];
    }
  }

  static fromJS(data: any): WatchlistRenameCommand {
    data = typeof data === 'object' ? data : {};
    let result = new WatchlistRenameCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['watchlistId'] = this.watchlistId;
    data['newName'] = this.newName;
    return data;
  }
}

export interface IWatchlistRenameCommand {
  watchlistId?: string | undefined;
  newName?: string | undefined;
}

export class WatchlistUpdatePesksCommand
  implements IWatchlistUpdatePesksCommand
{
  watchlistId?: string | undefined;
  pesks?: string[] | undefined;

  constructor(data?: IWatchlistUpdatePesksCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.watchlistId = _data['watchlistId'];
      if (Array.isArray(_data['pesks'])) {
        this.pesks = [] as any;
        for (let item of _data['pesks']) this.pesks!.push(item);
      }
    }
  }

  static fromJS(data: any): WatchlistUpdatePesksCommand {
    data = typeof data === 'object' ? data : {};
    let result = new WatchlistUpdatePesksCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['watchlistId'] = this.watchlistId;
    if (Array.isArray(this.pesks)) {
      data['pesks'] = [];
      for (let item of this.pesks) data['pesks'].push(item);
    }
    return data;
  }
}

export interface IWatchlistUpdatePesksCommand {
  watchlistId?: string | undefined;
  pesks?: string[] | undefined;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
